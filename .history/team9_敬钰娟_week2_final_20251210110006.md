# team_姓名_week2_final.md

## 一、实验概述

本次实验围绕Linux基础操作、Python/C++环境搭建、ROS1 Noetic安装与入门、Turtlesim仿真及通信机制展开，通过理论学习与实操结合，完成从环境配置到功能实现的全流程任务，加深对机器人操作系统基础框架与开发流程的理解。

## 二、实验环境

- 操作系统：Ubuntu 20.04 LTS（兼容ROS1 Noetic版本）
- 开发工具：Visual Studio Code（简称VSCode）
- 核心框架：ROS1 Noetic
- 仿真模块：Turtlesim

## 三、实验任务与步骤

### （一）任务1：Linux基础命令练习

#### 1. 文件管理操作（创建/移动/删除）

- **创建文件与目录**：使用`mkdir`创建多级目录`test_dir/sub_dir`，`touch`创建空文件`test.txt`，命令如下：

  ```bash
  mkdir -p test_dir/sub_dir  # 递归创建多级目录
  touch test_dir/test.txt    # 在test_dir下创建空文件
  ls -lah test_dir           # 查看目录内容（含隐藏文件与详细信息）

移动文件：将test.txt移动到sub_dir目录，并重命名为moved_test.txt：
bash
运行
mv test_dir/test.txt test_dir/sub_dir/moved_test.txt
删除文件与目录：强制删除test_dir及其所有内容：
bash
运行
rm -rf test_dir  # 谨慎使用！强制递归删除目录
操作效果截图：


2. 软件安装（apt 工具）
通过apt安装常用工具tree（目录结构可视化工具），命令如下：
bash
运行
sudo apt update  # 更新软件源列表
sudo apt install tree  # 安装tree工具
tree ~/          # 测试工具，查看家目录结构
操作效果截图：


3. 进程管理（ps 与 kill）
查看进程：使用ps aux查看所有进程，结合grep筛选firefox进程（若已打开）：
bash
运行
ps aux | grep firefox
终止进程：通过进程 ID（PID）强制终止目标进程，命令如下：
bash
运行
kill -9 12345  # 12345替换为实际firefox进程的PID
操作效果截图：


（二）任务 2：Python 与 C++ 编程练习
1. Python HelloWorld
编写代码：创建hello_python.py文件，内容如下：
python
运行
print("Hello World from Python!")
# 简单计算功能：两数相加
a = 5
b = 3
print(f"Sum of {a} and {b} is {a + b}")
运行程序：在终端执行命令，查看输出结果：
bash
运行
python3 hello_python.py
运行效果截图：


2. C++ 简单程序（输入数字求和）
编写代码：创建sum_cpp.cpp文件，实现从键盘输入两个整数并输出和：
cpp
运行
#include <iostream>
using namespace std;

int main() {
    int num1, num2;
    cout << "Enter first number: ";
    cin >> num1;
    cout << "Enter second number: ";
    cin >> num2;
    cout << "Sum: " << num1 + num2 << endl;
    return 0;
}
g++ 编译与运行：使用g++编译代码，生成可执行文件并运行：
bash
运行
g++ sum_cpp.cpp -o sum_cpp  # 编译代码，生成可执行文件sum_cpp
./sum_cpp                   # 运行程序
编译运行截图：


3. VSCode 调试配置
安装插件：打开 VSCode，在扩展市场搜索并安装Python（微软官方插件）、C/C++ Extension Pack插件。
Python 调试配置：
打开hello_python.py文件，点击左侧「运行和调试」按钮，选择「创建 launch.json 文件」。
选择「Python」->「Python 文件」，自动生成launch.json配置，内容如下：
json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: 当前文件",
            "type": "python",
            "request": "launch",
            "program": "${file}",
            "console": "integratedTerminal"
        }
    ]
}
在代码中设置断点，点击「启动调试」，观察变量变化与程序执行流程。
调试效果截图：


（三）任务 3：ROS1 安装验证
1. ROS1 Noetic 安装（关键步骤）
参考Ubuntu20.04 安装 ROS Noetic 详细教程，执行以下核心命令：
bash
运行
# 设置软件源
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
# 添加密钥
sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C6548
# 安装ROS Noetic（完整版）
sudo apt update
sudo apt install ros-noetic-desktop-full
# 初始化rosdep
sudo rosdep init
rosdep update
# 设置环境变量（添加到.bashrc，永久生效）
echo "source /opt/ros/noetic/setup.bash" >> ~/.bashrc
source ~/.bashrc
2. 安装验证
启动 roscore：打开终端，执行roscore，若显示「started core service [/rosout]」则启动成功：
bash
运行
roscore
查看节点列表：打开新终端，执行rosnode list，显示/rosout节点：
bash
运行
rosnode list
查看环境变量：执行echo $ROS_PACKAGE_PATH，显示 ROS 包路径：
bash
运行
echo $ROS_PACKAGE_PATH
验证效果截图：


（四）任务 4：CATKIN 工作空间与功能包
1. 创建 Catkin 工作空间
执行以下命令创建catkin_ws工作空间，并编译：
bash
运行
mkdir -p ~/catkin_ws/src  # 创建src目录（存放功能包）
cd ~/catkin_ws            # 进入工作空间
catkin_make               # 编译工作空间，生成build、devel目录
source devel/setup.bash   # 设置当前工作空间环境变量
2. 创建功能包与 HelloWorld 节点
创建功能包：在src目录下创建beginner_tutorials功能包，依赖roscpp、rospy、std_msgs：
bash
运行
cd ~/catkin_ws/src
catkin_create_pkg beginner_tutorials roscpp rospy std_msgs
编写 Python HelloWorld 节点：在beginner_tutorials/scripts目录下创建hello_ros.py：
python
运行
#!/usr/bin/env python3
import rospy

if __name__ == "__main__":
    rospy.init_node("hello_ros_node")  # 初始化节点
    rospy.loginfo("Hello World from ROS Python Node!")  # 打印日志
    rospy.spin()  # 保持节点运行
添加执行权限并运行：
bash
运行
chmod +x ~/catkin_ws/src/beginner_tutorials/scripts/hello_ros.py  # 添加执行权限
cd ~/catkin_ws
catkin_make  # 重新编译
source devel/setup.bash
rosrun beginner_tutorials hello_ros.py  # 运行节点
操作效果截图：


（五）任务 5：Turtlesim 小乌龟基础
1. 键盘控制小乌龟
打开三个终端，分别执行以下命令：
bash
运行
# 终端1：启动roscore
roscore
# 终端2：启动Turtlesim仿真节点
rosrun turtlesim turtlesim_node
# 终端3：启动键盘控制节点
rosrun turtlesim turtle_teleop_key
按终端 3 中的提示（如i前进、j左转、l右转）控制小乌龟移动。
操作效果截图：


2. rostopic 控制小乌龟
查看话题：执行rostopic list，找到小乌龟速度控制话题/turtle1/cmd_vel。
发布速度指令：通过rostopic pub发布线性速度（x 方向 1.0 m/s）指令，控制小乌龟直线运动：
bash
运行
rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist "linear:
x: 1.0
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.0"
-r 1表示每秒发布 1 次指令，小乌龟将持续前进，留下运动轨迹。
操作效果截图：


3. 程序控制小乌龟画圆（Python 实现）
编写代码：在beginner_tutorials/scripts目录下创建turtle_circle.py，通过发布cmd_vel话题让小乌龟画圆：
python
运行
#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import Twist

def turtle_circle():
    rospy.init_node("turtle_circle_node", anonymous=True)  # 初始化节点
    pub = rospy.Publisher("/turtle1/cmd_vel", Twist, queue_size=10)  # 创建发布者
    rate = rospy.Rate(10)  # 10Hz发布频率
    vel_msg = Twist()  # 初始化速度消息

    while not rospy.is_shutdown():
        # 设置线性速度（x方向0.5 m/s，前进）
        vel_msg.linear.x = 0.5
        vel_msg.linear.y = 0.0
        vel_msg.linear.z = 0.0
        # 设置角速度（z方向0.5 rad/s，左转）
        vel_msg.angular.x = 0.0
        vel_msg.angular.y = 0.0
        vel_msg.angular.z = 0.5

        pub.publish(vel_msg)  # 发布速度指令
        rate.sleep()  # 按频率休眠

if __name__ == "__main__":
    try:
        turtle_circle()
    except rospy.ROSInterruptException:
        pass
运行程序：
bash
运行
chmod +x ~/catkin_ws/src/beginner_tutorials/scripts/turtle_circle.py
cd ~/catkin_ws
catkin_make
source devel/setup.bash
# 终端1：roscore（若未启动）
# 终端2：rosrun turtlesim turtlesim_node
# 终端3：运行画圆程序
rosrun beginner_tutorials turtle_circle.py
运行效果截图：


（六）任务 6：多乌龟 launch + rqt_graph
1. 创建 launch 文件
在beginner_tutorials目录下创建launch文件夹，新建multi_turtle.launch文件，内容如下（启动 2 只小乌龟，分别使用turtle1和turtle2命名空间）：
xml
<launch>
    <!-- 启动第一只小乌龟，命名空间turtle1 -->
    <node name="turtlesim1" pkg="turtlesim" type="turtlesim_node" ns="turtle1">
        <!-- 重映射话题，避免与第二只乌龟冲突 -->
        <remap from="/turtle1/turtle1/cmd_vel" to="/turtle1/cmd_vel"/>
    </node>
    <!-- 启动第二只小乌龟，命名空间turtle2 -->
    <node name="turtlesim2" pkg="turtlesim" type="turtlesim_node" ns="turtle2">
        <remap from="/turtle2/turtle1/cmd_vel" to="/turtle2/cmd_vel"/>
    </node>
    <!-- 启动rqt_graph，自动显示通信关系 -->
    <node name="rqt_graph" pkg="rqt_graph" type="rqt_graph" />
</launch>
2. 运行 launch 文件与控制多乌龟
启动 launch：
bash
运行
cd ~/catkin_ws
source devel/setup.bash
roslaunch beginner_tutorials multi_turtle.launch
分别控制两只乌龟：
控制turtle1前进：
bash
运行
rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist "linear:
x: 1.0
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.0"
控制turtle2左转画圆：
bash
运行
rostopic pub -r 1 /turtle2/cmd_vel geometry_msgs/Twist "linear:
x: 0.5
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.8"
3. rqt_graph 与 rqt_plot 可视化
查看通信关系：launch 文件自动启动rqt_graph，可看到两只乌龟的节点、话题及通信链路；也可手动启动：
bash
运行
rqt_graph
绘制速度曲线：使用rqt_plot查看turtle1的线性速度（linear/x）：
bash
运行
rqt_plot /turtle1/cmd_vel/linear/x
可视化效果截图：


四、实验总结
知识掌握：通过本次实验，熟练掌握了 Linux 文件 / 进程 / 软件管理命令，完成了 Python/C++ 开发环境与 ROS1 Noetic 的搭建，理解了 ROS 工作空间、功能包、节点、话题的核心概念，以及 launch 文件对多节点的批量管理。
问题与解决：
问题 1：rosdep update失败，提示网络超时。
解决：更换国内源（如阿里云、清华源），或手动下载rosdep配置文件到指定目录。
问题 2：多乌龟话题冲突，控制指令无法区分。
解决：使用命名空间（ns）隔离节点，结合remap重映射话题名称，确保指令精准发送。
后续改进：可尝试用 C++ 实现小乌龟画圆功能，或通过rviz进一步可视化乌龟运动状态，深入学习 ROS 服务、参数服务器等其他通信机制。